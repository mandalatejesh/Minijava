//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirstSecondPass<R,A> extends GJDepthFirst<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   HashMap<String, funcData> glr;
   int stackIndex;
   int sCount;
   public class spillInfo{
      boolean isSpilled;
      Integer spilled;
      Integer flag; 
      spillInfo(){
         flag = 0;
         spilled = -1;
         isSpilled = false;
      }
      public void init(){
         flag = 0;
         spilled = -1;
         isSpilled = false;
      }
   };
    String reg(Integer t, spillInfo s){ // get register number of temporary t
      funcData fd = glr.get(presentfunc);
	   allocation b=fd.regallocation.get(t); // get register allocation for the current temporary
      if(b.flag!=1){
	      s.isSpilled = true;
	      s.spilled=b.spilled;
         if(s.flag==-1){
            return "ERROR";
         }
         else{
		      System.out.println("\tALOAD v"+s.flag+" SPILLEDARG "+b.spilled);
         }
	      return "v"+s.flag;
      }
      return b.register;
   }
   String presentfunc;
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

    public R visit(NodeListOptional n, A argu) {
       if ( n.present() ) {
         R _ret=null;
         int _count=0;
         LinkedList<R> l = new LinkedList<R>();
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            l.add(e.nextElement().accept(this,argu));
            _count++;
         }
         return (R) l;
      }
      else
         return null;
   }

    public R visit(NodeOptional n, A argu) {
      if ( n.present() ){
         String lab=(String) n.node.accept(this,argu);
         System.out.println(lab+" ");
         return (R)lab;
         }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      sCount=0;
      R _ret=null;
      glr = (HashMap<String, funcData>) argu;
      presentfunc = "MAIN";
      funcData fd = glr.get(presentfunc);
      System.out.println("MAIN [0] ["+(fd.spilled+1)+"] ["+(fd.argcalls+1)+"]");
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      System.out.println("END");
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      sCount++;
      presentfunc = (String) n.f0.accept(this, argu);
      funcData fd = glr.get(presentfunc);
      n.f1.accept(this, argu);
      String p = (String) n.f2.accept(this, argu);
      Integer param = Integer.valueOf(p);
      System.out.println(presentfunc+" ["+param+"] ["+(fd.spilled)+"] ["+fd.argcalls+"]");
      int i, t;
      i = t = 0;
      if(param>4){
         t = param-4;
      }
      for(i=0;i<8;i++){
         System.out.println("\tASTORE SPILLEDARG "+(i+t)+" s"+i);
      }
      for(i=0;i<10;i++){
    	  System.out.println("\tASTORE SPILLEDARG "+(i+t+8)+" t"+i);
      }
      for(i=0;i<4 &&i<param;i++){
    	  	System.out.println("\tMOVE s"+i+" a"+i);
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      for(i=0;i<8;i++){
    	  System.out.println("\tALOAD s"+i+" SPILLEDARG "+(i+t));
      }
      for(i=0;i<10;i++){
    	  System.out.println("\tALOAD t"+i+" SPILLEDARG "+(i+t+8));
      }
      System.out.println("END");

      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      sCount++;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      System.out.println("\tNOOP");
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      System.out.println("\tERROR");
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t = (String)n.f1.accept(this, argu);
      String lab = (String)n.f2.accept(this, argu);
      String curRegister = "";
      funcData fd = glr.get(presentfunc);
	   allocation b=fd.regallocation.get(Integer.valueOf(t)); // get register allocation for the current temporary
      if(b.flag==1){
         curRegister = (String) b.register;
      }
      else{
		   System.out.println("\tALOAD v"+1+" SPILLEDARG "+b.spilled);
         curRegister = "v1"; // load the spilled arg into v1 register
      }
      System.out.println("\tCJUMP "+curRegister+" "+lab);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String lab = (String)n.f1.accept(this, argu);
      System.out.println("\tJUMP "+lab);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      R t1 = n.f1.accept(this, argu);
      String num = (String) n.f2.accept(this, argu);
      R t2 = n.f3.accept(this, argu);
      funcData fd = glr.get(presentfunc);
	   allocation b1=fd.regallocation.get(Integer.valueOf((String)t1)); // get register allocation for the current temporary
	   allocation b2=fd.regallocation.get(Integer.valueOf((String)t2)); // get register allocation for the current temporary
      String b="",c="";
      if(b1.flag==1){
         b = (String) b1.register;
      }
      else{
		   System.out.println("\tALOAD v0 SPILLEDARG "+b1.spilled);
         b = "v0";
      }
      if(b2.flag==1){
         c = (String) b2.register;
      }
      else{
		   System.out.println("\tALOAD v1 SPILLEDARG "+b2.spilled);
         c = "v1";
      }
      System.out.println("\tHSTORE "+b+" "+num+" "+c);

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      R t1 = n.f1.accept(this, argu);
      R t2 = n.f2.accept(this, argu);
      String num = (String) n.f3.accept(this, argu);

      funcData fd = glr.get(presentfunc);
	   allocation b1=fd.regallocation.get(Integer.valueOf((String)t1)); // get register allocation for the current temporary
	   allocation b2=fd.regallocation.get(Integer.valueOf((String)t2)); // get register allocation for the current temporary
      String b="",c="";
      boolean savespill = false;
      if(b1.flag==1){
         b = (String) b1.register;
      }
      else{
		   System.out.println("\tALOAD v0 SPILLEDARG "+b1.spilled);
         b = "v0";
         savespill = true;
      }
      if(b2.flag==1){
         c = (String) b2.register;
      }
      else{
		   System.out.println("\tALOAD v1 SPILLEDARG "+b2.spilled);
         c = "v1";
      }
      System.out.println("\tHLOAD "+ b + " "+ c + " "+num);
      if(savespill){
         System.out.println("\tASTORE SPILLEDARG "+b1.spilled+" "+b);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = (String)n.f1.accept(this, argu);
      Integer i = Integer.valueOf(t1);
      n.f2.accept(this, (A)i);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String s1 = (String)n.f1.accept(this, argu);
      System.out.println("\tPRINT "+s1);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      _ret=n.f0.accept(this, argu);
      if(n.f0.which==3){
    	  String b=(String)_ret;
      funcData fd = glr.get(presentfunc);
	   allocation al=fd.regallocation.get((Integer)argu); // get register allocation for the current temporary
      if(al.flag==1){
    		System.out.println("\tMOVE "+al.register+" "+b);
      }
      else{
         System.out.println("\tASTORE SPILLEDARG "+ al.spilled + " "+b);
      }
      }
      if(n.f0.which==1){
    	  String b=(String)_ret;
       funcData fd = glr.get(presentfunc);
	   allocation al=fd.regallocation.get((Integer)argu); // get register allocation for the current temporary
      if(al.flag==1){
    		System.out.println("\tMOVE "+al.register+" HALLOCATE "+b);
      }
      else{
		   System.out.println("\tALOAD v0 SPILLEDARG "+al.spilled);
         System.out.println("\tASTORE SPILLEDARG "+ al.spilled + " v0");
      }
      }
      if(n.f0.which==0){
    	  spillInfo s = new spillInfo();
         s.flag = -1;
    	  String c=reg((Integer)argu,s);
    	  if(s.isSpilled)
    		  System.out.println("\tASTORE SPILLEDARG "+s.spilled+" v0 ");
    	  else
    		  System.out.println("\tMOVE "+c+" v0");
    	  
      }
    	
      return _ret; // returning null
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      sCount++;
      String b=(String)n.f3.accept(this, argu);
      System.out.println("\tMOVE v0 "+b);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String s=(String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      LinkedList<R> l=(LinkedList<R>)n.f3.accept(this, argu);
      if(l==null){
         l = new LinkedList<R>();
      }
      spillInfo sf = new spillInfo();
      String c;
      
      for(Integer it = 0; it<l.size();it++){
    	  sf.flag = 0;
        sf.init();
    	  c=reg(Integer.valueOf((String)l.get(it)),sf);
    	  if(it<=3){
    			  System.out.println("\tMOVE a"+it+" "+c);
    		  }
    	  else
    	  {
    		  System.out.println("\tPASSARG "+(it-3)+" "+c);
    	  }
      }
      System.out.println("\tCALL "+s);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String op = (String) n.f0.accept(this, argu);
      String temp = (String) n.f1.accept(this, argu);
      String s = (String)n.f2.accept(this, argu);
      spillInfo sf = new spillInfo();
      sf.flag = 0;
      String c=reg(Integer.valueOf(temp),sf);
      spillInfo sf1 = new spillInfo();
      sf1.flag = -1;
      String d=reg((Integer)argu,sf1);
      if(sf1.isSpilled){
    	  System.out.println("\tMOVE v0 "+op+" "+c+" "+s);
        System.out.println("\tASTORE SPILLEDARG "+sf1.spilled+" v0");
      }
      else
    	  System.out.println("\tMOVE "+d+" "+op+" "+c+" "+s);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret= null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      if(n.f0.which==0){
         spillInfo sf = new spillInfo();
         sf.flag = 1;
         _ret = (R)reg(Integer.valueOf((String)_ret),sf);
      }
      else if(n.f0.which==1){
         System.out.println("\tMOVE v1 "+(String)_ret);
         _ret = (R)"v1";
      }
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

}
